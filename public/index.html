<!DOCTYPE html>
<html>
<head>
	<title></title>
	<script src="plugins/jquery/jquery.min.js"></script>
</head>
<body>

</body>
<script>
var systems_ = {}
var params_ = {
	name1: "Anett Kontaveit"
	, name2: "Jaqueline Adina Cristian"
}

var ERFC_COF = [
  -2.8e-17, 1.21e-16, -9.4e-17, -1.523e-15, 7.106e-15,
   3.81e-16, -1.12708e-13, 3.13092e-13, 8.94487e-13,
  -6.886027e-12, 2.394038e-12, 9.6467911e-11,
  -2.27365122e-10, -9.91364156e-10, 5.059343495e-9,
   6.529054439e-9, -8.5238095915e-8, 1.5626441722e-8,
   1.303655835580e-6, -1.624290004647e-6,
  -2.0278578112534e-5, 4.2523324806907e-5,
   3.66839497852761e-4, -9.46595344482036e-4,
  -9.561514786808631e-3, 1.9476473204185836e-2,
   6.4196979235649026e-1, -1.3026537197817094
];
var ERFC_COF_LAST = ERFC_COF[ERFC_COF.length - 1];

function erfc(x) {
  function erfccheb(y) {
    var d = 0.0, dd = 0.0, temp = 0.0,
        t = 2.0 / (2.0 + y), ty = 4.0 * t - 2.0;
  
    for (var i = 0, l = ERFC_COF.length - 1; i < l; i++) {
      temp = d;
      d = ty * d - dd + ERFC_COF[i];
      dd = temp;
    }
  
    return t * Math.exp(-y * y + 0.5 * (ERFC_COF_LAST + ty * d) - dd);
  }
  
  return x >= 0.0 ? erfccheb(x) : 2.0 - erfccheb(-x);
}

function eloFn(eloDiff) {
	var formula = $("input[name=formula]:checked").val();
	return (formula == "normal") ?
	       eloNormal(eloDiff) : eloLogistic(eloDiff);
}

function invEloFn(p) {
	var formula = $("input[name=formula]:checked").val();
	return (formula == "normal") ?
	       invEloNormal(p) : invEloLogistic(p);
}

function bestOf3(p) {
	var q = 1-p;
	return p*p*(p + 3*q);
}

function bestOf5(p) {
	var q = 1-p;
	return p*p*p*(p*p + 5*p*q + 10*q*q);
}

function bestOf7(p) {
	var q = 1-p;
	return p*p*p*p*(p*p*p + 7*p*p*q + 21*p*q*q + 35*q*q*q);
}

function margin2(p) {
	var q = 1-p;
	return (p*p) / (p*p + q*q);
}

function margin3(p) {
	var q = 1-p;
	return (p*p*p) / (p*p*p + q*q*q);
}

</script>
<script src="js/utils.js"></script>
<script src="js/tennis-women.js"></script>
<script>
var system = systems_['tennis-women']
function applyParams() {

	// What we're going to show in the UI.
	var rating1 = "";
	var name1 = "";
	var info1 = "";
	var rating2 = "";
	var name2 = "";
	var info2 = "";

	var eloDiff = "";
	var eloInfo = "";
	var eScore = "";

	var tournament = "best-of";
	var bestOf = 1;
	var margin = 1;
	var score = "0-0";

	// Maintain a high-precision version of some parameters.
	var eloDiffH = parseFloat(eloDiff);
	var eScoreH = parseFloat(eScore);
	var drawProbH = 0;

	// Block 1.
	if ("name1" in params_) {
		name1 = params_.name1;
		var i = findByName(name1, system);
		if (i != -1) {
			name1 = system.list[i][0];	// Fix name in case of fuzzy match.
			params_.name1 = name1;
			rating1 = system.getRating(system.list[i]);
			info1 = system.getInfo(system.list[i]);
		}
	}

	if ("name2" in params_) {
		name2 = params_.name2;
		var i = findByName(name2, system);
		if (i != -1) {
			name2 = system.list[i][0];	// Fix name in case of fuzzy match.
			params_.name2 = name2;
			rating2 = system.getRating(system.list[i]);
			info2 = system.getInfo(system.list[i]);
		}
	}

	if (rating1 != "" && rating2 != "") {
		eloDiffH = system.eloDiff(parseFloat(rating1), parseFloat(rating2),"random");
		eloDiff = eloDiffH.toFixed(0);
		eScoreH = eloFn(eloDiffH);
		eScore = eScoreH.toFixed(9);
	}

	// Block 3.
	if ("best_of" in params_) {
		bestOf = params_.best_of;
		tournament = "best-of";
	}

	if ("margin" in params_) {
		margin = params_.margin;
		tournament = "margin";
	}

	if ("score" in params_)
		score = params_.score;

	// Show the variables in the UI.
	console.log(eScore)
	updateProbabilities(eScoreH, drawProbH);
}

// Use high-precision eScore and drawProb to avoid rounding issues.
/**
* NaN, 0
*/
function updateProbabilities(eScore, drawProb) {
	var scoreStr = "0-0"
	var parts = scoreStr.split("-");
	var s1 = 0;
	var s2 = 0;
	if (parts.length == 2) {
		s1 = parseFloat(parts[0]);
		s2 = parseFloat(parts[1]);
	}

	// var tournament = $("input[name=tournament]:checked").val();
	var tournament = "best-of"
	var probs;

	if (parts.length != 2)
		probs = ["(current score has wrong format)", "", ""];
	else if (tournament == "best-of") {
		// var n = parseInt($("input[name=best-of]").val());
		var n = 1
		var winProb = eScore - drawProb/2;
		probs = computeProbBestOf(n, winProb, drawProb, s1, s2);
	}
	else if (tournament == "margin") {
		if (drawProb == 0) {
			var n = parseInt($("input[name=margin]").val());
			probs = computeProbMargin(n, eScore, s1, s2);
		}
		else {
			probs = ["(margin-of-two with non-zero draw probability is not implemented)", "", ""];
		}
	
	}
	else
		probs = ["?", "?", "?"];
	// $("span#win1").text(probs[0]);
	// $("span#win2").text(probs[1]);
	// $("span#draw").text(probs[2]);
	console.log(probs)
}

function computeProbBestOf(n, winProb, drawProb, s1, s2) {
	if (s1 * 2 != Math.floor(s1 * 2) || s2 * 2 != Math.floor(s2 * 2))
		return ["(current score is not composed of half-integers)", "", ""];
	if (s1 + s2 != Math.floor(s1 + s2))
		return ["(current score doesn't sum to an integer)", "", ""];
	if (isNaN(n) || isNaN(winProb) || isNaN(drawProb))
		return ["?", "?", "?"];
	if (s1 < 0 || s2 < 0)
		return ["(current score contains a negative number)", "", ""];
	if (s1 + s2 > n)
		return ["(current score sum exceeds match length)", "", ""];

	// Allocate. Tables are indexed by units of half-points.
	var winTable = [];
	var drawTable = [];
	for (var i = 0; i <= 2*n; i++) {
		winTable[i] = [];
		drawTable[i] = [];
	}

	// Boundary conditions.
	for (var i = 0; i <= 2*n; i++) {
		var j = 2*n - i;
		winTable[i][j] = (i > j ? 1 : 0);
		drawTable[i][j] = (i == j ? 1 : 0);
	}

	// Fill rest using recurrence.
	var loseProb = 1 - winProb - drawProb;
	for (var sum = n - 1; sum >= s1 + s2; sum--) {
		for (var i = 0; i <= 2*sum; i++) {
			var j = 2*sum - i;
			winTable[i][j] = winProb * winTable[i+2][j] +
			                 drawProb * winTable[i+1][j+1] +
			                 loseProb * winTable[i][j+2];
			drawTable[i][j] = winProb * drawTable[i+2][j] +
			                  drawProb * drawTable[i+1][j+1] +
			                  loseProb * drawTable[i][j+2];
		}
	}
	var win = winTable[s1*2][s2*2];
	var draw = drawTable[s1*2][s2*2];
	var lose = 1 - win - draw;

	// Prevent "-0.000000000" from being displayed.
	if (Math.abs(win) < 1e-10) win = 0;
	if (Math.abs(lose) < 1e-10) lose = 0;
	if (Math.abs(draw) < 1e-10) draw = 0;

	return [win.toFixed(9), lose.toFixed(9), draw.toFixed(9)];
}

function computeProbMargin(n, p, s1, s2) {
	if (s1 != Math.floor(s1) || s2 != Math.floor(s2))
		return ["(current score is not composed of integers)", "", ""];
	if (isNaN(n) || isNaN(p))
		return ["?", "?", "?"];
	if (s1 < 0 || s2 < 0)
		return ["(current score contains a negative number)", "", ""];

	var E = p*p / (1 - 2*(1-p)*p);	// Prob if equal.
	var A = (1 - (1-p)*p)/p * E;	// Prob if player1 advantage.
	var D = p * E;					// Prob if player1 disadvantage.

	var win;
	if (s1 > n || s2 > n) {
		var diff = s1 - s2;
		if (diff == 2)
			win = 1;
		else if (diff == 1)
			win = A;
		else if (diff == 0)
			win = E;
		else if (diff == -1)
			win = D;
		else if (diff == -2)
			win = 0;
		else
			return ["?", "?", "?"];
	}
	else {
		// Allocate.
		var winTable = [];
		for (var i = 0; i <= n; i++)
			winTable[i] = [];

		// Boundary conditions.
		for (var i = 0; i <= n-2; i++) {
			winTable[i][n] = 0;
			winTable[n][i] = 1;
		}
		winTable[n][n] = E;
		winTable[n][n-1] = A;
		winTable[n-1][n] = D;

		// Fill rest using recurrence.
		for (var i = n - 1; i >= s1; i--) {
			for (var j = n - 1; j >= s2; j--) {
				winTable[i][j] = p * winTable[i+1][j] +
			                	 (1 - p) * winTable[i][j+1];
			}
		}
		win = winTable[s1][s2];
	}

	var lose = 1 - win;
	var draw = 0;
	return [win.toFixed(9), lose.toFixed(9), draw.toFixed(9)];
}

function eloFn(eloDiff) {
	// var formula = $("input[name=formula]:checked").val();
	var formula = "logistic"
	return (formula == "normal") ?
	       eloNormal(eloDiff) : eloLogistic(eloDiff);
}

</script>
</html>